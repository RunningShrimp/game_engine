# ADR-0002: 使用Actor模式进行并发控制

**状态**: 已采用  
**日期**: 2025-12-01  
**决策者**: 架构团队

## 上下文

游戏引擎需要处理多个并发系统（音频、物理、渲染），传统的共享状态并发模型（Mutex、Arc）容易导致死锁和性能问题。

## 决策

采用Actor模式进行并发控制：
- 每个系统（音频、物理、渲染）作为独立的Actor
- Actor之间通过消息传递通信
- Actor内部状态不可变，通过消息更新
- 使用 `crossbeam-channel` 实现消息传递

## 后果

### 优点
- **无死锁**: Actor之间通过消息通信，避免共享状态
- **可测试性**: Actor可以独立测试，消息可以模拟
- **可扩展性**: 可以轻松添加新的Actor
- **性能**: 消息传递比Mutex更高效

### 缺点
- **消息序列化**: 需要序列化消息（但Rust零成本抽象可以优化）
- **调试困难**: 异步消息传递可能难以调试
- **学习曲线**: 团队需要理解Actor模式

### 实施细节
- Actor系统位于 `src/domain/actor.rs`
- 消息类型定义在 `src/domain/actor.rs`
- 使用 `ActorHandle` 发送消息

## 替代方案

1. **共享状态 + Mutex**: 使用 `Arc<Mutex<T>>` 共享状态
   - 拒绝原因: 容易死锁，性能较差

2. **无锁数据结构**: 使用 `crossbeam` 无锁队列
   - 部分采用: 在Actor内部使用无锁队列

3. **异步任务**: 使用 `tokio` 异步任务
   - 未来考虑: 如果需要更复杂的异步操作

## 相关决策

- ADR-0001: 使用领域驱动设计
- ADR-0004: 错误处理和恢复策略



