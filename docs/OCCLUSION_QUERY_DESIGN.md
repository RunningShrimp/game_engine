# 遮挡查询设计文档

**创建日期**: 2025-01-XX  
**任务**: T1.4.2 - 实现Hi-Z遮挡查询算法  
**状态**: 🔄 进行中

---

## 执行摘要

设计并实现完整的Hi-Z遮挡查询算法，替换当前的占位实现。遮挡查询是遮挡剔除系统的核心功能，用于快速检测对象是否被其他对象遮挡。

**目标**:
- 实现完整的GPU端遮挡查询计算着色器
- 实现遮挡查询接口
- 集成到渲染管线
- 预期性能提升20-30%（复杂场景）

---

## 1. 算法设计

### 1.1 Hi-Z遮挡查询原理

**基本思想**:
1. 将对象的AABB投影到屏幕空间
2. 在Hi-Z层次结构中从粗到细查询
3. 如果AABB的最小深度值大于Hi-Z中的最大深度值，则对象被遮挡

**查询流程**:
1. **投影AABB**: 将世界空间的AABB投影到屏幕空间，得到屏幕空间的AABB
2. **层次查询**: 从Hi-Z的最高mip级别开始查询
   - 如果屏幕空间AABB覆盖的区域的最大深度值小于AABB的最小深度值，则对象可见
   - 如果屏幕空间AABB覆盖的区域的最大深度值大于AABB的最小深度值，则对象可能被遮挡，需要查询更细的mip级别
3. **精确查询**: 在最低mip级别进行精确查询，确定对象是否被遮挡

### 1.2 优化策略

**早期退出**:
- 如果对象在视锥体外，直接标记为不可见
- 如果对象在屏幕外，直接标记为不可见
- 如果对象在Hi-Z的最高mip级别就确定可见，不需要查询更细的级别

**批量查询**:
- 使用计算着色器批量处理多个查询
- 减少GPU-CPU同步开销

---

## 2. 实现设计

### 2.1 数据结构

```rust
/// 遮挡查询结构
#[repr(C)]
struct OcclusionQuery {
    /// AABB最小点（世界空间）
    aabb_min: Vec3,
    /// AABB最大点（世界空间）
    aabb_max: Vec3,
    /// 查询结果（0=遮挡，1=可见）
    visible: u32,
    /// 查询ID（用于标识查询）
    query_id: u32,
}

/// 遮挡查询统一缓冲区
struct OcclusionQueryUniforms {
    /// 视图投影矩阵
    view_proj: Mat4,
    /// 屏幕分辨率
    screen_size: Vec2,
    /// Hi-Z层级数
    mip_levels: u32,
    /// 查询数量
    query_count: u32,
}
```

### 2.2 计算着色器设计

**输入**:
- Hi-Z纹理（所有mip级别）
- 查询缓冲区（包含AABB和查询ID）
- 统一缓冲区（视图投影矩阵、屏幕分辨率等）

**输出**:
- 查询结果缓冲区（可见性标志）

**算法步骤**:
1. 读取查询的AABB
2. 投影AABB到屏幕空间
3. 检查AABB是否在屏幕内
4. 层次查询Hi-Z
5. 写入查询结果

---

## 3. 接口设计

### 3.1 遮挡查询接口

```rust
impl HierarchicalZCulling {
    /// 执行遮挡查询
    ///
    /// 对多个AABB进行遮挡查询，返回可见性结果。
    ///
    /// ## 参数
    ///
    /// * `encoder` - 命令编码器
    /// * `device` - WGPU设备
    /// * `queue` - WGPU队列
    /// * `queries` - 查询列表（AABB）
    /// * `view_proj` - 视图投影矩阵
    /// * `screen_size` - 屏幕分辨率
    ///
    /// ## 返回
    ///
    /// 返回可见性结果（Vec<bool>）
    pub fn query_occlusion(
        &self,
        encoder: &mut wgpu::CommandEncoder,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        queries: &[Aabb],
        view_proj: Mat4,
        screen_size: (u32, u32),
    ) -> Result<Vec<bool>, OcclusionError>;
}
```

---

## 4. 性能优化

### 4.1 GPU优化

- **批量查询**: 使用计算着色器批量处理多个查询
- **早期退出**: 在着色器中实现早期退出，减少不必要的计算
- **共享内存**: 使用workgroup共享内存缓存Hi-Z采样结果

### 4.2 CPU优化

- **异步查询**: 使用异步查询减少CPU等待时间
- **查询合并**: 合并多个小查询为一个大查询
- **查询缓存**: 缓存查询结果，避免重复查询

---

## 5. 集成计划

### 5.1 集成到渲染管线

1. **深度预渲染阶段**: 渲染场景到深度缓冲
2. **Hi-Z构建阶段**: 构建Hi-Z层次缓冲
3. **遮挡查询阶段**: 对可见对象进行遮挡查询
4. **渲染阶段**: 只渲染未被遮挡的对象

### 5.2 集成到GPU驱动渲染

- 在`GpuDrivenRenderer`中添加遮挡查询支持
- 在间接绘制前进行遮挡查询
- 使用查询结果过滤不可见的实例

---

## 6. 测试计划

### 6.1 单元测试

- 测试AABB投影
- 测试Hi-Z查询
- 测试遮挡判断

### 6.2 集成测试

- 测试遮挡查询管线
- 测试性能提升
- 测试正确性

### 6.3 性能测试

- 测试不同场景复杂度下的性能
- 测试不同查询数量的性能
- 对比CPU和GPU查询性能

---

**设计完成日期**: 2025-01-XX  
**下一步**: 实现遮挡查询计算着色器和接口

