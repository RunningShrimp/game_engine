# 聚合根设计文档

本文档描述领域层的聚合根设计和边界定义。

## 聚合根概览

### 1. Scene（场景聚合根）

**职责**：
- 管理场景中的所有实体
- 控制场景的生命周期（加载、激活、停用、卸载）
- 确保场景级别的业务规则

**边界**：
- 包含：`GameEntity`集合、场景元数据、场景状态
- 不包含：渲染管线、物理世界（这些是基础设施层）

**业务规则**：
1. 场景必须有名称（不能为空）
2. 场景状态转换必须遵循生命周期：Unloaded → Loading → Loaded → Active/Inactive → Unloaded
3. 活跃场景最多只能有一个活跃相机
4. 实体ID在场景内必须唯一
5. 场景激活时，所有实体必须激活

**不变性**：
- 场景ID不可变
- 场景名称不可变（创建后）
- 实体集合通过聚合根方法修改

### 2. GameEntity（实体聚合根）

**职责**：
- 封装实体的所有组件
- 管理实体状态（活跃、非活跃、待删除）
- 提供实体操作（移动、旋转、缩放）

**边界**：
- 包含：Transform、Sprite、PointLight、Camera等组件
- 不包含：渲染管线、物理引擎（这些是基础设施层）

**业务规则**：
1. 实体不能同时拥有Sprite和Camera组件
2. Transform的缩放值必须为正数
3. 待删除的实体不能激活
4. 实体必须有ID

**不变性**：
- 实体ID不可变
- 实体状态通过聚合根方法修改

### 3. RenderScene（渲染场景聚合根）

**职责**：
- 管理场景中的所有渲染对象
- 协调可见性剔除和LOD决策
- 管理渲染策略

**边界**：
- 包含：`RenderObject`集合、LOD选择器、视锥体
- 不包含：GPU资源、渲染管线（这些是基础设施层）

**业务规则**：
1. 渲染对象ID必须唯一
2. 视锥体必须设置后才能更新场景
3. LOD选择器必须配置后才能更新场景
4. 只有可见的渲染对象才会被LOD处理

**不变性**：
- 渲染对象集合通过聚合根方法修改
- LOD选择器和视锥体通过聚合根方法设置

## 值对象

### Position（位置值对象）

**职责**：封装3D位置信息

**验证规则**：
- 坐标值必须是有限数（不能是NaN或无穷大）

**不变性**：值对象是不可变的

### Rotation（旋转值对象）

**职责**：封装四元数旋转信息

**验证规则**：
- 四元数自动归一化

**不变性**：值对象是不可变的

### Scale（缩放值对象）

**职责**：封装3D缩放信息

**验证规则**：
- 缩放值必须为正数
- 缩放值必须是有限数

**不变性**：值对象是不可变的

### Transform（变换值对象）

**职责**：封装位置、旋转、缩放的组合

**验证规则**：
- 继承Position、Rotation、Scale的验证规则

**不变性**：值对象是不可变的

## 聚合边界原则

1. **通过聚合根访问**：所有对聚合内实体的访问必须通过聚合根
2. **事务边界**：聚合是事务边界，一个事务只能修改一个聚合
3. **引用其他聚合**：只能通过ID引用其他聚合，不能直接持有引用
4. **业务规则封装**：所有业务规则必须在聚合边界内执行

## 示例

### 正确的使用方式

```rust
// 通过聚合根添加实体
let mut scene = Scene::new(SceneId(1), "My Scene");
let entity = GameEntity::new(EntityId(1));
scene.add_entity(entity)?; // ✅ 通过聚合根方法

// 通过聚合根修改实体
if let Some(entity) = scene.get_entity_mut(EntityId(1)) {
    entity.set_position(position)?; // ✅ 通过聚合根获取的可变引用
}
```

### 错误的使用方式

```rust
// ❌ 直接访问聚合内部
scene.entities.insert(entity_id, entity); // 违反封装

// ❌ 绕过业务规则
entity.state = EntityState::Active; // 应该使用activate()方法
```

## 未来改进

1. **领域事件**：添加领域事件支持，用于聚合间通信
2. **快照机制**：完善快照机制，支持聚合状态恢复
3. **版本控制**：为聚合添加版本号，支持乐观并发控制
4. **更多值对象**：识别更多可封装为值对象的领域概念

